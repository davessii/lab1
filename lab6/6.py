import numpy as np
#преобразовать список в массив
A = np.array([[1, 2, 3], [4, 5, 6]])
print(A)
#скопировать массив 
B = A.copy()
print(B)
#создать нулевой или единичный массив заданного размера
A = np.zeros((2, 3))
print(A)
B = np.ones((3, 2))
print(B)
#Либо взять размеры уже существующего массива
A = np.array([[1, 2, 3], [4, 5, 6]])
B = np.zeros_like(A)
print(B)

A = np.array([[1, 2, 3], [4, 5, 6]])
B = np.ones_like(A)
print(B)
#при создании двумерного квадратного массива можете сделать его единичной диагональной матрицей
A = np.eye(3)
print(A)
#построить массив чисел от From (включая) до To (не включая) с шагом Step
From = 2.5
To = 7
Step = 0.5
A = np.arange(From, To, Step)
print(A)
#По умолчанию from = 0, step = 1, поэтому возможен вариант с одним параметром, интерпретируемым как To
A = np.arange(5)
print(A)
#Либо с двумя — как From и To
A = np.arange(10, 15)
print(A)
#Обратите внимание, что в методе №3 размеры массива передавались в качестве одного параметра (кортеж размеров). Вторым параметром в способах №3 и №4 можно указать желаемый тип элементов массива
A = np.zeros((2, 3), 'int')
print(A)

B = np.ones((3, 2), 'complex')
print (B)
#Используя метод astype, можно привести массив к другому типу. В качестве параметра указывается желаемый тип
A = np.ones((3, 2))
B = A.astype('str')
print(B)
#Доступ к элементам массива осуществляется по целочисленным индексами, начинается отсчет с 0
A = np.array([[1, 2, 3], [4, 5, 6]])
print(A[1, 1])
#Если представить многомерный массив как систему вложенных одномерных массивов (линейный массив, элементы которого могут быть линейными массивами), становится очевидной возможность получать доступ к подмассивам с использованием неполного набора индексов
A = np.array([[1, 2, 3], [4, 5, 6]])
print(A[1])
#С учетом этой парадигмы, можем переписать пример доступа к одному элементу
A = np.array([[1, 2, 3], [4, 5, 6]])
print(A[1][1])
#При использовании неполного набора индексов, недостающие индексы неявно заменяются списком всех возможных индексов вдоль соответствующей оси. Сделать это явным образом можно, поставив ":". Предыдущий пример с одним индексом можно переписать в следующем виде
A = np.array([[1, 2, 3], [4, 5, 6]])
print(A[1, :])

#«Пропустить» индекс можно вдоль любой оси или осей, если за «пропущенной» осью последуют оси с индексацией, то ":" обязательно
A = np.array([[1, 2, 3], [4, 5, 6]])
print(A[:, 1])
#Индексы могут принимать отрицательные целые значения. В этом случае отсчет ведется от конца массива
A = np.arange(5)
print(A)
print(A[-1])
#Можно использовать не одиночные индексы, а списки индексов вдоль каждой оси
A = np.arange(5)
print(A)

#Либо диапазоны индексов в виде «From:To:Step». Такая конструкция называется срезом. Выбираются все элементы по списку индексов начиная с индекса From включительно, до индекса To не включая с шагом Step
A = np.arange(5)
print(A)
A[0:4:2]
#Шаг индекса имеет значение по умолчанию 1 и может быть пропущен
A = np.arange(5)
print(A)
A[0:4]
#Шаг индекса имеет значение по умолчанию 1 и может быть пропущен
A = np.arange(5)
print(A)
A[:4]
#Значения From и To тоже имеют дефолтные значения: 0 и размер массива по оси индексации соответственно
A = np.arange(5)
print(A)
A[-3:]
#Если вы хотите использовать From и To по умолчанию (все индексы по данной оси) а шаг отличный от 1, то вам необходимо использовать две пары двоеточий, чтобы интерпретатор смог идентифицировать единственный параметр как Step. Следующий код «разворачивает» массив вдоль второй оси, а вдоль первой не меняет
A = np.array([[1, 2, 3], [4, 5, 6]])
B = A[:, ::-1]
print("A", A)
print("B", B)
#А теперь выполним
print(A)
B[0, 0] = 0
print(A)
#Как видите, через B мы изменили данные в A. Вот почему в реальных задачах важно использовать копии. Пример выше должен был бы выглядеть так
A = np.array([[1, 2, 3], [4, 5, 6]])
B = A.copy()[:, ::-1]
print("A", A)
print("B", B)
#В NumPy также реализована возможность доступа ко множеству элементов массива через булев индексный массив. Индексный массив должен совпадать по форме с индексируемым
A = np.array([[1, 2, 3], [4, 5, 6]])
I = np.array([[False, False, True], [ True, False, True]])
A[I]
#Как видите, такая конструкция возвращает плоский массив, состоящий из элементов индексируемого массива, соответствующих истинным индексам. Однако, если мы используем такой доступ к элементам массива для изменения их значений, то форма массива сохранится
A = np.array([[1, 2, 3], [4, 5, 6]])
I = np.array([[False, False, True], [ True, False, True]])
A[I] = 0
print(A)


#Над индексирующими булевыми массивами определены логические операции logical_and, logical_or и logical_not выполняющие логические операции И, ИЛИ и НЕ поэлементно
A = np.array([[1, 2, 3], [4, 5, 6]])

I1 = np.array([[False, False, True], [True, False, True]])
I2 = np.array([[False, True, False], [False, False, True]])

B = A.copy()
C = A.copy()
D = A.copy()

B[np.logical_and(I1, I2)] = 0
C[np.logical_or(I1, I2)] = 0
D[np.logical_not(I1)] = 0

print('B\n', B)
print('\nC\n', C)
print('\nD\n', D)


#logical_and и logical_or принимают 2 операнда, logical_not — один. Можно использовать операторы &, | и ~ для выполнения И, ИЛИ и НЕ соответственно с любым количеством операндов
A = np.array([[1, 2, 3], [4, 5, 6]])

I1 = np.array([[False, False, True], [True, False, True]])
I2 = np.array([[False, True, False], [False, False, True]])

A[I1 & (I1 | ~ I2)] = 0

print(A)
#Что эквивалентно применению только I1.

#Получить индексирующий логический массив, соответсвующий по форме массиву значений можно, записав логическое условие с именем массива в качестве операнда. Булево значение индекса будет рассчитано как истинность выражения для соответствующего элемента массива.

#Найдем индексирующий массив I элементов, которые больше, чем 3, а элементы со значениями меньше чем 2 и больше 4 — обнулим
A = np.array([[1, 2, 3], [4, 5, 6]])
print('A before\n', A)

I = A > 3
print('I\n', I)

A[np.logical_or(A < 2, A > 4)] = 0
print('A after\n', A)

#Многомерный массив можно представить как одномерный массив максимальной длины, нарезанный на фрагменты по длине самой последней оси и уложенный слоями по осям, начиная с последних.

#Для наглядности рассмотрим пример
A = np.arange(24)
B = A.reshape(4, 6)
C = A.reshape(4, 3, 2)
print('B\n', B)
print('\nC\n', C)

#В этом примере мы из одномерного массива длиной 24 элемента сформировали 2 новых массива. Массив B, размером 4 на 6. Если посмотреть на порядок значений, то видно, что вдоль второго измерения идут цепочки последовательных значений.

#В массиве C, размером 4 на 3 на 2, непрерывные значения идут вдоль последней оси. Вдоль второй оси идут последовательно блоки, объединение которых дало бы в результате строки вдоль второй оси массива B.

#А учитывая, что мы не делали копии, становится понятно, что это разные формы преставления одного и того же массива данных. Поэтому можно легко и быстро менять форму массива, не изменяя самих данных.

#Чтобы узнать размерность массива (количество осей), можно использовать поле ndim (число), а чтобы узнать размер вдоль каждой оси — shape (кортеж). Размерность можно также узнать и по длине shape. Чтобы узнать полное количество элементов в массиве можно воспользоваться значением size:
A = np.arange(24)
C = A.reshape(4, 3, 2)

print(C.ndim, C.shape, len(C.shape), A.size)

#Обратите внимание, что ndim и shape — это атрибуты, а не методы!

#Чтобы увидеть массив одномерным, можно воспользоваться функцией ravel
A = np.array([[1, 2, 3], [4, 5, 6]])
A.ravel()
#Чтобы поменять размеры вдоль осей или размерность используется метод reshape
A = np.array([[1, 2, 3], [4, 5, 6]])
A.reshape(3, 2)




#Учитывая, что количество элементов постоянно, размер вдоль одной любой оси при выполнении reshape может быть вычислен из значений длины вдоль других осей. Размер вдоль одной оси можно обозначить -1 и тогда он будет вычислен автоматически
A = np.arange(24)
B = A.reshape(4, -1)
C = A.reshape(4, -1, 2)

print(B.shape, C.shape)

#Можно reshape использовать вместо ravel
A = np.array([[1, 2, 3], [4, 5, 6]])
B = A.reshape(-1)
print(B.shape)
